{"mappings":"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","sources":["src/converter.tsx","src/logger.ts","src/fileProcessor.tsx","src/index.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertMarkdownToJSX = exports.convertMarkdownFilesToJSXFiles = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _server = require(\"react-dom/server\");\n\nvar _reactMarkdown = _interopRequireDefault(require(\"react-markdown\"));\n\nvar _grayMatter = _interopRequireDefault(require(\"gray-matter\"));\n\nvar _json = require(\"json5\");\n\nvar _logger = require(\"./logger\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Converts Markdown files to JSX files, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {string[]} `markdownFiles` Markdown strings to convert that may also include front-matter and html.\r\n * @param {string} `outputFolderPath` Front matter to stringify.\r\n * @param {string} `reactContextName` name of react context object to assign front-matter variables to.\r\n * @return {Promise<JsxFiles>} Files containing jsx\r\n */\nconst convertMarkdownFilesToJSXFiles = async (markdownFiles, reactContextVarName, reactContextName) => {\n  const files = await Promise.all(markdownFiles.map(async file => {\n    const frontMatterAndMarkdown = extractFrontMatter(file.data, reactContextVarName, reactContextName);\n    const jsxString = convertMarkdownAndHtmlToJsx(frontMatterAndMarkdown.markdownString);\n    const reactComponentString = createJsxComponentString(file.fileName, jsxString, frontMatterAndMarkdown.frontMatterJsxString);\n    return {\n      fileName: file.fileName,\n      data: reactComponentString\n    };\n  }));\n  return files;\n};\n/**\r\n * Converts Markdown to JSX, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {string} `markdownString` Markdown string to convert to a react component that may also include front-matter and html.\r\n * @param {componentName} `componentName` Name of new react component.\r\n * @param {string} `reactContextVarName` name of react context variable name to assign front-matter variables to. like [shuji, setShuji] = useContext(...)\r\n * @param {string} `reactContextName` name of react context object to assign front-matter variables to.\r\n * @return {Promise<string>} Front matter and Markdown JSX strings\r\n */\n\n\nexports.convertMarkdownFilesToJSXFiles = convertMarkdownFilesToJSXFiles;\n\nconst convertMarkdownToJSX = async (markdownString, componentName, reactContextVarName, reactContextName) => {\n  const frontMatterAndMarkdown = extractFrontMatter(markdownString, reactContextVarName, reactContextName);\n  const jsxString = convertMarkdownAndHtmlToJsx(frontMatterAndMarkdown.markdownString);\n  const reactComponentString = createJsxComponentString(componentName, jsxString, frontMatterAndMarkdown.frontMatterJsxString);\n  return reactComponentString;\n};\n\nexports.convertMarkdownToJSX = convertMarkdownToJSX;\n\nconst convertMarkdownAndHtmlToJsx = markdownString => {\n  try {\n    const jsxString = (0, _server.renderToStaticMarkup)( /*#__PURE__*/_react.default.createElement(_reactMarkdown.default, {\n      children: markdownString\n    }));\n    const jsxStringWithTabs = jsxString.replace(/(\\n|\\r)/g, c => c + '\\t\\t\\t');\n    return jsxStringWithTabs;\n  } catch (error) {\n    (0, _logger.logger)().error(`error converting markdown to jsx: ${error}`);\n    throw new error();\n  }\n};\n\nconst extractFrontMatter = (stringWithFrontMatter, reactContextVarName, reactContextName) => {\n  try {\n    const {\n      data,\n      content\n    } = (0, _grayMatter.default)(stringWithFrontMatter);\n    const frontMatterJsxString = createFrontMatterJSXString(data, reactContextVarName, reactContextName);\n    return {\n      frontMatterJsxString: frontMatterJsxString,\n      markdownString: content\n    };\n  } catch (error) {\n    (0, _logger.logger)().error(`failed to extract front matter: ${error}`);\n    throw new error();\n  }\n};\n\nconst createFrontMatterJSXString = (propsToAssign, reactContextVarName, reactContextName) => {\n  if (Object.keys(propsToAssign).length < 1) return ''; //Example\n  // const [metadata, setMetadata] = useContext('TestContext')\n  // setMetadata({\n  //     ...metadata,\n  //     date = '2021-01-01',\n  //     title = 'node is cool',\n  //     slug = 'node-is-cool',\n  //     description = 'How to node',\n  //     tags = ['node','cool','shuji']\n  // })\n\n  const setContextVarName = 'set' + reactContextVarName.replace(/^\\w/, c => c.toUpperCase());\n  const camelCasedVarName = reactContextVarName.replace(/^\\w/, c => c.toLowerCase());\n  let propAssignmentString = '';\n\n  for (const propName in propsToAssign) {\n    const propValue = propsToAssign[propName];\n    let propValueStringified = (0, _json.stringify)(propValue);\n    propAssignmentString += `\\t\\t${propName} = ${propValueStringified}, \\n`;\n  }\n\n  const contextAssignmentString = `\\n\\tconst [${camelCasedVarName}, ${setContextVarName}] = useContext('${reactContextName}')` + `\\n\\n\\t${setContextVarName}({` + `\\n\\t\\t...${camelCasedVarName},` + `\\n${propAssignmentString}` + `\\n\\t})\\n`;\n  return contextAssignmentString;\n};\n\nconst createJsxComponentString = (componentName, reactString, frontMatterString) => {\n  const capitalizedMethodName = componentName.replace(/^\\w/, c => c.toUpperCase());\n  const camelCasedComponentName = componentName.replace(/^\\w/, c => c.toLowerCase());\n  let reactComponent = `export const ${capitalizedMethodName} = () => { \\n ${frontMatterString}\n    return (\n        <div className='${camelCasedComponentName}'>\n            ${reactString}\n        </div>\n    )\\n}`;\n  return reactComponent;\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logger = logger;\nexports.setLogLevel = setLogLevel;\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//TODO make this a real logger\nfunction logger() {\n  const shujiPurple = _chalk.default.hex('#6C63A2');\n\n  const debug = message => {\n    if (logLevel > 1) return;\n\n    const blue = _chalk.default.hex('#58a6ff');\n\n    console.log(shujiPurple('Shuji: ') + blue(message));\n  };\n\n  const info = message => {\n    if (logLevel > 2) return;\n\n    const blue = _chalk.default.hex('#58a6ff');\n\n    console.log(shujiPurple('Shuji: ') + blue(message));\n  };\n\n  const warn = message => {\n    if (logLevel > 2) return;\n\n    const orange = _chalk.default.hex('#FFA500');\n\n    console.log(shujiPurple('Shuji: ') + orange(message));\n  };\n\n  const error = (message, error) => {\n    if (logLevel > 2) return;\n\n    const red = _chalk.default.hex('#ff7b72');\n\n    const fullErrorMessage = error ? message + `\\n actual error: ${error.message} \\n ${error.stack}` : message;\n    console.log(shujiPurple('Shuji: ') + red(fullErrorMessage));\n  };\n\n  return {\n    debug,\n    info,\n    warn,\n    error\n  };\n} // level 1 = debug\n// level 2 = default\n// level 3 = no logging\n\n\nlet logLevel = 2;\n\nfunction setLogLevel(level) {\n  logLevel = level;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsxFiles = exports.getMdFilesFromFolder = void 0;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n\nvar _logger = require(\"./logger\");\n\nconst getMdFilesFromFolder = async path => {\n  let mdFiles = [];\n\n  try {\n    const pathStat = await _fs.promises.lstat(path);\n    const isPathADirectory = pathStat.isDirectory();\n    const fileNamesInDir = isPathADirectory ? await _fs.promises.readdir(path) : [(0, _path.basename)(path)];\n\n    if (fileNamesInDir.length < 1) {\n      (0, _logger.logger)().warn(`No .md files found in '${path}'`);\n      return mdFiles;\n    }\n\n    (0, _logger.logger)().info(`Processing ${fileNamesInDir.length} file${fileNamesInDir.length > 1 ? 's' : ''} from \"${path}\"...`);\n    mdFiles = await fileNamesInDir.reduce(async (validFilesPromise, fileName) => {\n      const validFiles = await validFilesPromise;\n      if ((0, _path.extname)(fileName) != '.md') return validFiles;\n      const filePath = isPathADirectory ? `${path}/${fileName}` : path;\n      const fileData = await _fs.promises.readFile(filePath);\n      validFiles.push({\n        fileName: (0, _path.basename)(fileName, '.md'),\n        data: fileData.toString()\n      });\n      return validFiles;\n    }, Promise.resolve([]));\n  } catch (err) {\n    (0, _logger.logger)().warn(`No .md files found in inputPath: '${path}'`);\n  }\n\n  return mdFiles;\n};\n\nexports.getMdFilesFromFolder = getMdFilesFromFolder;\n\nconst writeJsxFiles = async (folderPath, jsxFiles, deleteExistingOutputFolder) => {\n  try {\n    if (jsxFiles.length <= 0) return;\n    if (deleteExistingOutputFolder) await _fs.promises.rmdir(folderPath);\n    (0, _logger.logger)().info(`Generating ${jsxFiles.length} file${jsxFiles.length > 1 ? 's' : ''} in \"${folderPath}\"...`);\n    await _fs.promises.mkdir(folderPath, {\n      recursive: true\n    });\n    await Promise.all(jsxFiles.map(async jsxFile => {\n      await _fs.promises.writeFile(`${folderPath}/${jsxFile.fileName}.jsx`, jsxFile.data, 'utf8');\n    }));\n  } catch (error) {\n    (0, _logger.logger)().error(`error writing markdown files: ${error}`);\n  }\n};\n\nexports.writeJsxFiles = writeJsxFiles;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformMarkdownFiles = exports.transformMarkdownString = exports.defaultOptions = void 0;\n\nvar _converter = require(\"./converter\");\n\nvar _fileProcessor = require(\"./fileProcessor\");\n\nvar _logger = require(\"./logger\");\n\nconst {\n  performance,\n  PerformanceObserver,\n  PerformanceEntry\n} = require(\"perf_hooks\");\n\nconst defaultOptions = {\n  inputPath: 'markdown',\n  outputPath: 'jsxMarkdown',\n  reactContextName: 'ShujiContext',\n  reactContextVarName: 'shuji',\n  deleteExistingOutputFolder: false\n}; //TODO: use typescript types\n\nexports.defaultOptions = defaultOptions;\nconst perfObserver = new PerformanceObserver(items => {\n  items.getEntries().forEach(entry => {\n    const trimmedDuration = parseInt(entry.duration);\n\n    if (entry.name == 'shuji') {\n      (0, _logger.logger)().info(`Done in ${trimmedDuration}ms.`);\n      return;\n    }\n\n    (0, _logger.logger)().debug(`${entry.name} finished in ${trimmedDuration}ms.`);\n  });\n});\nperfObserver.observe({\n  entryTypes: [\"measure\"],\n  buffer: true\n});\n/**\r\n * Transforms a Markdown string to JSX, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {string} `markdownString` Markdown string to convert to a react component that may also include front-matter and html.\r\n * @param {componentName} `componentName` Name of new react component.\r\n * @param {Options} User defined options to override default values.\r\n * @return {Promise<number>} files\r\n */\n\nconst transformMarkdownString = async (markdownString, componentName, options) => {\n  try {\n    performance.mark('start-shuji');\n    const userOptions = { ...defaultOptions,\n      ...options\n    };\n    const jsxString = await (0, _converter.convertMarkdownToJSX)(markdownString, componentName, userOptions.reactContextVarName, userOptions.reactContextName);\n    return jsxString;\n  } catch (error) {\n    return '';\n  } finally {\n    performance.mark('end-shuji');\n    performance.measure('shuji', 'start-shuji', 'end-shuji');\n  }\n};\n/**\r\n * Transforms Markdown files to JSX files, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {Options} User defined options to override default values.\r\n * @return {Promise<number>} files\r\n */\n\n\nexports.transformMarkdownString = transformMarkdownString;\n\nconst transformMarkdownFiles = async options => {\n  try {\n    performance.mark('start-shuji');\n    const userOptions = { ...defaultOptions,\n      ...options\n    };\n    const mdFiles = await (0, _fileProcessor.getMdFilesFromFolder)(userOptions.inputPath);\n    const jsxStrings = await (0, _converter.convertMarkdownFilesToJSXFiles)(mdFiles, userOptions.reactContextVarName, userOptions.reactContextName);\n    await (0, _fileProcessor.writeJsxFiles)(userOptions.outputPath, jsxStrings, userOptions.deleteExistingOutputFolder);\n    return 0;\n  } catch (error) {\n    return 1;\n  } finally {\n    performance.mark('end-shuji');\n    performance.measure('shuji', 'start-shuji', 'end-shuji');\n  }\n};\n\nexports.transformMarkdownFiles = transformMarkdownFiles;"],"names":["$ef41a945f0ad9b72d9d658553d0d8690$var$_react","$ef41a945f0ad9b72d9d658553d0d8690$var$_interopRequireDefault","$2PElU$react","$ef41a945f0ad9b72d9d658553d0d8690$var$_reactMarkdown","$2PElU$reactmarkdown","$ef41a945f0ad9b72d9d658553d0d8690$var$_grayMatter","$2PElU$graymatter","shujiPurple","chalk","hex","message","logLevel","blue","console","log","orange","error","red","fullErrorMessage","stack","level","$c08bde6a2c7ebbc4ffc54f57ff3d4fab$var$_chalk","$2PElU$chalk","convertMarkdownFilesToJSXFiles","reactComponentString","files","$ef41a945f0ad9b72d9d658553d0d8690$var$convertMarkdownAndHtmlToJsx","frontMatterAndMarkdown","markdownString","convertMarkdownToJSX","async","componentName","reactContextVarName","reactContextName","$ef41a945f0ad9b72d9d658553d0d8690$var$extractFrontMatter","frontMatterJsxString","stringWithFrontMatter","data","content","default","$ef41a945f0ad9b72d9d658553d0d8690$var$createFrontMatterJSXString","propsToAssign","propName","path","mdFiles","isPathADirectory","promises","lstat","isDirectory","fileNamesInDir","readdir","$2PElU$basename","length","$c08bde6a2c7ebbc4ffc54f57ff3d4fab$exports","logger","warn","info","reduce","validFilesPromise","fileName","validFiles","$2PElU$extname","filePath","fileData","readFile","push","toString","Promise","resolve","err","folderPath","jsxFiles","deleteExistingOutputFolder","rmdir","mkdir","recursive","all","map","jsxFile","writeFile","$2PElU$performance","$2PElU$PerformanceObserver","defaultOptions","inputPath","outputPath","$7d09df7f6586727d9bda14a00ae6ddb6$require$PerformanceObserver","items","getEntries","forEach","entry","trimmedDuration","parseInt","duration","name","debug","observe","entryTypes","buffer","mark","transformMarkdownFiles","measure","options"],"version":3,"file":"index.js.map","sourceRoot":"../"}