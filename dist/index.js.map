{"mappings":"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","sources":["./src/converter.tsx","./src/fileProcessor.tsx","./src/index.ts"],"sourcesContent":["import React from 'react'\r\nimport { renderToStaticMarkup } from 'react-dom/server'\r\nimport ReactMarkdown from 'react-markdown'\r\nimport matter from 'gray-matter'\r\nimport { stringify } from 'json5'\r\n\r\ninterface File {\r\n    fileName: string\r\n    data: string\r\n}\r\n\r\ninterface FrontMatterAndJSX {\r\n    frontMatterJsxString: string\r\n    jsxString: string\r\n}\r\ninterface FrontMatterSplitFromMarkdown {\r\n    frontMatterJsxString: string\r\n    markdownString: string\r\n}\r\n\r\n/**\r\n * Converts Markdown files to JSX files, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {string[]} `markdownFiles` Markdown strings to convert that may also include front-matter and html.\r\n * @param {string} `outputFolderPath` Front matter to stringify.\r\n * @param {string} `reactContextName` name of react context object to assign front-matter variables to.\r\n * @return {Promise<JsxFiles>} Files containing jsx\r\n */\r\nexport const convertMarkdownFilesToJSXFiles = async (markdownFiles: File[], reactContextVarName: string, reactContextName: string): Promise<File[]> => {\r\n    const files = await Promise.all(\r\n        markdownFiles.map(async file => {\r\n            const frontMatterAndMarkdown = extractFrontMatter(file.data, reactContextVarName, reactContextName)\r\n            const jsxString = convertMarkdownAndHtmlToJsx(frontMatterAndMarkdown.markdownString)\r\n            const reactComponentString = createJsxComponentString(file.fileName, jsxString, frontMatterAndMarkdown.frontMatterJsxString)\r\n            return { fileName: file.fileName, data: reactComponentString }\r\n        })\r\n    )\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Converts Markdown to JSX, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {string[]} `markdownStrings` Markdown strings to convert that may also include front-matter and html.\r\n * @param {string} `outputFolderPath` Front matter to stringify.\r\n * @param {string} `reactContextVarName` name of react context variable name to assign front-matter variables to. like [shuji, setShuji] = useContext(...)\r\n * @param {string} `reactContextName` name of react context object to assign front-matter variables to.\r\n * @return {Promise<FrontMatterAndJSX>} Front matter and Markdown JSX strings\r\n */\r\nexport const convertMarkdownToJSX = async (markdownString: string, reactContextVarName: string, reactContextName: string): Promise<FrontMatterAndJSX> => {\r\n    const frontMatterAndMarkdown = extractFrontMatter(markdownString, reactContextVarName, reactContextName)\r\n    const jsxString = convertMarkdownAndHtmlToJsx(frontMatterAndMarkdown.markdownString)\r\n\r\n    return {\r\n        frontMatterJsxString: frontMatterAndMarkdown.frontMatterJsxString,\r\n        jsxString: jsxString\r\n    }\r\n}\r\n\r\nconst convertMarkdownAndHtmlToJsx = (markdownString: string): string => {\r\n    try {\r\n        const jsxString = renderToStaticMarkup(<ReactMarkdown children={markdownString}  />)\r\n        const jsxStringWithTabs = jsxString.replace(/(\\n|\\r)/g, c => c + '\\t\\t\\t')\r\n        return jsxStringWithTabs\r\n    } catch (error) {\r\n        console.log(`error converting markdown to jsx: ${error}`)\r\n        throw new error()\r\n    }\r\n}\r\n\r\nconst extractFrontMatter = (stringWithFrontMatter: string, reactContextVarName: string, reactContextName: string): FrontMatterSplitFromMarkdown => {\r\n    try {\r\n        const { data, content } = matter(stringWithFrontMatter)\r\n        const frontMatterJsxString = createFrontMatterJSXString(data, reactContextVarName, reactContextName)\r\n\r\n        return {\r\n            frontMatterJsxString: frontMatterJsxString,\r\n            markdownString: content\r\n        }\r\n    } catch (error) {\r\n        console.log(`failed to extract front matter: ${error}`)\r\n        throw new error()\r\n    }\r\n}\r\n\r\nconst createFrontMatterJSXString = (propsToAssign: Object, reactContextVarName: string, reactContextName: string): string => {\r\n    if(Object.keys(propsToAssign).length < 1)\r\n        return ''\r\n\r\n    //Example\r\n    // const [metadata, setMetadata] = useContext('TestContext')\r\n    // setMetadata({\r\n    //     ...metadata,\r\n    //     date = '2021-01-01',\r\n\t//     title = 'node is cool',\r\n\t//     slug = 'node-is-cool',\r\n\t//     description = 'How to node',\r\n\t//     tags = ['node','cool','shuji']\r\n    // })\r\n\r\n    const setContextVarName = 'set' + reactContextVarName.replace(/^\\w/, c => c.toUpperCase())\r\n    const camelCasedVarName = reactContextVarName.replace(/^\\w/, c => c.toLowerCase())\r\n\r\n    let propAssignmentString = ''\r\n\r\n    for (const propName in propsToAssign) {\r\n        const propValue = propsToAssign[propName as keyof Object]\r\n        let propValueStringified = stringify(propValue)\r\n\r\n        propAssignmentString += `\\t\\t${propName} = ${propValueStringified}, \\n`\r\n    }\r\n\r\n    const contextAssignmentString =\r\n    `\\n\\tconst [${camelCasedVarName}, ${setContextVarName}] = useContext('${reactContextName}')`\r\n    + `\\n\\n\\t${setContextVarName}({`\r\n        + `\\n\\t\\t...${camelCasedVarName},`\r\n        + `\\n${propAssignmentString}`\r\n    + `\\n\\t})\\n`\r\n\r\n    return contextAssignmentString\r\n}\r\n\r\nconst createJsxComponentString = (componentName: string, reactString: string, frontMatterString?: string): string => {\r\n   const capitalizedMethodName = componentName.replace(/^\\w/, c => c.toUpperCase())\r\n   const camelCasedComponentName = componentName.replace(/^\\w/, c => c.toLowerCase())\r\n    let reactComponent = `export const ${capitalizedMethodName} = () => { \\n ${frontMatterString}\r\n    return (\r\n        <div className='${camelCasedComponentName}'>\r\n            ${reactString}\r\n        </div>\r\n    )\\n}`\r\n\r\n    return reactComponent\r\n}\r\n","import { promises } from 'fs'\r\nimport { extname, basename } from 'path'\r\n\r\ntype File = {\r\n    fileName: string\r\n    data: string\r\n}\r\n\r\nexport const getMdFilesFromFolder = async (folderPath: string): Promise<File[]> => {\r\n    let mdFiles: File[] = []\r\n\r\n    try {\r\n        const fileNamesInDir = await promises.readdir(folderPath)\r\n\r\n        if (fileNamesInDir.length < 1) {\r\n            console.log(`Shuji: No .md files found in folder '${folderPath}'`)\r\n            return mdFiles\r\n        }\r\n\r\n        console.log(`Shuji: Processing ${fileNamesInDir.length} files...`)\r\n\r\n        mdFiles = await fileNamesInDir.reduce(async (validFilesPromise: Promise<File[]>, fileName: string) => {\r\n            const validFiles = await validFilesPromise\r\n\r\n            if (extname(fileName) != '.md') return validFiles\r\n\r\n            const fileData = await promises.readFile(`${folderPath}/${fileName}`)\r\n            validFiles.push({ fileName: basename(fileName, '.md'), data: fileData.toString() })\r\n        \r\n            return validFiles\r\n        }, Promise.resolve([]))\r\n    } catch (err) {\r\n        console.log(`Shuji: error retrieving files from '${folderPath}': ${err}`)\r\n    }\r\n\r\n    return mdFiles\r\n}\r\n\r\nexport const writeJsxFiles = async (folderPath: string, jsxFiles: File[], deleteExistingOutputFolder: boolean): Promise<void> => {\r\n    try {\r\n        if(deleteExistingOutputFolder)\r\n            await promises.rmdir(folderPath)\r\n\r\n        await promises.mkdir(folderPath, { recursive: true })\r\n        await Promise.all(\r\n            jsxFiles.map(async jsxFile => {\r\n                await promises.writeFile(`${folderPath}/${jsxFile.fileName}.jsx`, jsxFile.data, 'utf8')\r\n            })\r\n        )\r\n    } catch (error) {\r\n        console.log(`Shuji: error writing markdown files: ${error}`)\r\n    }\r\n}\r\n","import { convertMarkdownFilesToJSXFiles } from './converter'\r\nimport { getMdFilesFromFolder, writeJsxFiles } from './fileProcessor'\r\n\r\ninterface Options {\r\n    inputFolderPath?: string\r\n    outputFolderPath?: string\r\n    reactContextName?: string\r\n    reactContextVarName?: string\r\n    deleteExistingOutputFolder?: boolean\r\n}\r\n\r\nexport const defaultOptions = {\r\n    inputFolderPath: 'markdown',\r\n    outputFolderPath: 'jsxMarkdown',\r\n    reactContextName: 'ShujiContext',\r\n    reactContextVarName: 'shuji',\r\n    deleteExistingOutputFolder: false\r\n}\r\n\r\n/**\r\n * Converts Markdown files to JSX files, including any html in the markdown.\r\n * Also, front-matter will be extracted in js variables in the react component.\r\n * @param {Options} User defined options to override default values.\r\n * @return {Promise<number>} files\r\n */\r\nexport const compileMarkdown = async (options?: Options): Promise<number> => {\r\n    try {\r\n        const userOptions = {\r\n            ...defaultOptions,\r\n            ...options\r\n        }\r\n\r\n        const mdFiles = await getMdFilesFromFolder(userOptions.inputFolderPath)\r\n        const jsxStrings = await convertMarkdownFilesToJSXFiles(mdFiles, userOptions.reactContextVarName, userOptions.reactContextName)\r\n        await writeJsxFiles(userOptions.outputFolderPath, jsxStrings, userOptions.deleteExistingOutputFolder)\r\n\r\n        return 0\r\n    } catch (error) {\r\n        return 1\r\n    }\r\n}\r\n"],"names":["$b5eda152b6347c544474c79a45168ed$var$_react","$b5eda152b6347c544474c79a45168ed$var$_interopRequireDefault","_react","$b5eda152b6347c544474c79a45168ed$var$_server","_reactDomServer","$b5eda152b6347c544474c79a45168ed$var$_reactMarkdown","_reactMarkdown","$b5eda152b6347c544474c79a45168ed$var$_grayMatter","_grayMatter","$b5eda152b6347c544474c79a45168ed$var$_json","_json","async","markdownFiles","reactContextVarName","reactContextName","Promise","all","map","frontMatterAndMarkdown","extractFrontMatter","file","data","jsxString","convertMarkdownAndHtmlToJsx","markdownString","reactComponentString","createJsxComponentString","fileName","frontMatterJsxString","renderToStaticMarkup","default","createElement","children","replace","c","error","console","log","stringWithFrontMatter","content","createFrontMatterJSXString","propsToAssign","Object","keys","length","setContextVarName","toUpperCase","camelCasedVarName","toLowerCase","propAssignmentString","propName","propValue","stringify","componentName","reactString","frontMatterString","$ef231118494880909883b8bdab77b4d$var$_fs","_fs","$ef231118494880909883b8bdab77b4d$var$_path","_path","mdFiles","fileNamesInDir","promises","readdir","folderPath","reduce","validFilesPromise","validFiles","extname","fileData","readFile","push","basename","toString","resolve","err","jsxFiles","deleteExistingOutputFolder","rmdir","mkdir","recursive","writeFile","jsxFile","defaultOptions","inputFolderPath","outputFolderPath","userOptions","options","$ef231118494880909883b8bdab77b4d$exports","getMdFilesFromFolder","jsxStrings","$b5eda152b6347c544474c79a45168ed$exports","convertMarkdownFilesToJSXFiles","writeJsxFiles"],"version":3,"file":"index.js.map"}